# Архитектура проекта Personal Finance Manager

## Обзор

Проект построен на принципах **Clean Architecture** (чистая архитектура) с четким разделением ответственности между слоями.

## Слои архитектуры

### 1. Domain Layer (Доменный слой)

**Пакет**: `com.finances.core.domain`

Содержит бизнес-логику и доменные модели приложения. Этот слой не зависит от внешних фреймворков и библиотек.

#### Основные классы:

- **User** - представляет пользователя системы
  - Хранит username и хэш пароля
  - Предоставляет метод верификации пароля
  
- **Wallet** - кошелек пользователя
  - Хранит список транзакций
  - Управляет бюджетами
  - Вычисляет балансы и статистику
  
- **Transaction** - финансовая транзакция
  - Может быть доходом (INCOME) или расходом (EXPENSE)
  - Содержит категорию, сумму, дату и описание
  
- **Budget** - бюджет для категории расходов
  - Хранит лимит для категории
  - Позволяет изменять лимит
  
- **TransactionType** - enum для типов транзакций

#### Принципы:

- Все классы иммутабельны где возможно
- Валидация данных происходит в конструкторах
- Бизнес-правила инкапсулированы в методах доменных объектов

### 2. Service Layer (Слой сервисов)

**Пакет**: `com.finances.core.service`

Содержит бизнес-логику приложения, которая координирует работу доменных объектов.

#### Основные сервисы:

- **AuthService** - управление аутентификацией
  - Регистрация новых пользователей
  - Вход в систему
  - Хэширование паролей (SHA-256)
  - Управление текущей сессией
  
- **TransactionService** - управление транзакциями
  - Добавление доходов и расходов
  - Получение статистики по категориям
  - Фильтрация транзакций
  - Переводы между пользователями
  
- **BudgetService** - управление бюджетами
  - Установка и изменение бюджетов
  - Вычисление остатка бюджета
  - Проверка превышения бюджета
  - Расчет процента использования

#### Принципы:

- Сервисы зависят только от интерфейсов репозиториев
- Каждый сервис имеет единственную ответственность (SRP)
- Сервисы координируют работу доменных объектов

### 3. Repository Layer (Слой репозиториев)

**Пакет**: `com.finances.core.repository`

Определяет интерфейсы для работы с данными.

#### Интерфейсы:

- **UserRepository** - управление пользователями
  ```java
  void save(User user)
  Optional<User> findByUsername(String username)
  boolean existsByUsername(String username)
  ```

- **WalletRepository** - управление кошельками
  ```java
  void save(Wallet wallet)
  Optional<Wallet> findByUserId(String userId)
  void deleteByUserId(String userId)
  ```

#### Принципы:

- Абстракция от конкретной реализации хранения
- Использование паттерна Repository
- Возврат Optional для безопасной работы с null

### 4. Infrastructure Layer (Слой инфраструктуры)

**Пакет**: `com.finances.infrastructure`

Содержит реализацию технических деталей и внешних интеграций.

#### Компоненты:

##### Persistence (Хранение данных)

- **InMemoryUserRepository** - хранение пользователей в памяти
  - Использует HashMap для быстрого доступа
  
- **InMemoryWalletRepository** - хранение кошельков в памяти
  - Использует HashMap для быстрого доступа
  
- **FileStorage** - сохранение/загрузка данных в файлы
  - Сериализация в JSON (используя Gson)
  - Автоматическое создание директории wallets/
  - Экспорт данных в CSV и JSON форматы

##### Notification (Уведомления)

- **NotificationService** - генерация уведомлений
  - Проверка превышения бюджета
  - Предупреждение при 80% использования
  - Уведомление о превышении расходов над доходами
  - Предупреждение об отрицательном балансе

#### Принципы:

- Реализация интерфейсов из core слоя
- Изоляция технических деталей
- Легкая замена реализации (например, на базу данных)

### 5. CLI Layer (Слой представления)

**Пакет**: `com.finances.cli`

Пользовательский интерфейс командной строки.

#### Компоненты:

- **CLI** - основной класс интерфейса
  - Управление меню
  - Обработка ввода пользователя
  - Форматирование вывода
  - Обработка ошибок

#### Принципы:

- Разделение логики отображения от бизнес-логики
- Валидация пользовательского ввода
- Дружественные сообщения об ошибках
- Красивое форматирование вывода

## Диаграмма зависимостей

```
┌─────────────────────────────────────┐
│           CLI Layer                 │
│  ┌──────────────────────────────┐  │
│  │         CLI.java             │  │
│  └──────────────────────────────┘  │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│        Service Layer                │
│  ┌──────────────────────────────┐  │
│  │  AuthService                 │  │
│  │  TransactionService          │  │
│  │  BudgetService               │  │
│  └──────────────────────────────┘  │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│       Domain Layer                  │
│  ┌──────────────────────────────┐  │
│  │  User, Wallet                │  │
│  │  Transaction, Budget         │  │
│  └──────────────────────────────┘  │
└─────────────────────────────────────┘
              ↑
┌─────────────────────────────────────┐
│    Infrastructure Layer             │
│  ┌──────────────────────────────┐  │
│  │  InMemoryRepositories        │  │
│  │  FileStorage                 │  │
│  │  NotificationService         │  │
│  └──────────────────────────────┘  │
└─────────────────────────────────────┘
```

## Паттерны проектирования

### 1. Repository Pattern
Абстракция доступа к данным через интерфейсы UserRepository и WalletRepository.

### 2. Service Pattern
Инкапсуляция бизнес-логики в сервисные классы.

### 3. Dependency Injection
Внедрение зависимостей через конструкторы.

### 4. Builder Pattern
Используется в Gson для сериализации.

### 5. Strategy Pattern
Различные стратегии экспорта данных (CSV, JSON).

## Принципы SOLID

### Single Responsibility Principle (SRP)
Каждый класс имеет одну ответственность:
- User - представление пользователя
- Wallet - управление финансами
- AuthService - аутентификация
- TransactionService - транзакции

### Open/Closed Principle (OCP)
Система открыта для расширения, но закрыта для модификации:
- Легко добавить новый тип транзакции
- Легко добавить новый формат экспорта

### Liskov Substitution Principle (LSP)
Реализации репозиториев взаимозаменяемы через интерфейсы.

### Interface Segregation Principle (ISP)
Интерфейсы разделены по функциональности:
- UserRepository - только для пользователей
- WalletRepository - только для кошельков

### Dependency Inversion Principle (DIP)
Высокоуровневые модули не зависят от низкоуровневых:
- Сервисы зависят от интерфейсов репозиториев
- CLI зависит от интерфейсов сервисов

## Потоки данных

### Добавление транзакции

```
User Input (CLI)
    ↓
CLI.handleAddExpense()
    ↓
TransactionService.addExpense()
    ↓
Wallet.addTransaction()
    ↓
WalletRepository.save()
    ↓
InMemoryWalletRepository (HashMap)
```

### Проверка бюджета

```
TransactionService.addExpense()
    ↓
NotificationService.checkAndNotifyAfterTransaction()
    ↓
BudgetService.getRemainingBudget()
    ↓
Wallet.getRemainingBudget()
    ↓
Display notification to user
```

### Сохранение при выходе

```
CLI.handleLogout()
    ↓
WalletRepository.findByUserId()
    ↓
FileStorage.saveWallet()
    ↓
Gson serialization
    ↓
Write to wallets/username.wallet
```

## Обработка ошибок

### Валидация на уровне домена
```java
public Transaction(...) {
    if (amount <= 0) {
        throw new IllegalArgumentException("Amount must be positive");
    }
}
```

### Обработка на уровне CLI
```java
try {
    amount = Double.parseDouble(amountStr);
} catch (NumberFormatException e) {
    System.out.println("✗ Неверный формат суммы.");
    return;
}
```

### Обработка на уровне сервисов
```java
public Wallet getWallet(String userId) {
    return walletRepository.findByUserId(userId)
        .orElseThrow(() -> new IllegalStateException("Wallet not found"));
}
```

## Тестирование

### Unit-тесты
- Тестирование каждого класса изолированно
- Использование Mockito для моков
- Покрытие граничных случаев

### Интеграционные тесты
- Тестирование полного потока работы
- Проверка взаимодействия компонентов
- Тестирование сохранения/загрузки данных

## Будущие улучшения

1. **Замена хранилища на БД**
   - Реализовать JpaUserRepository
   - Реализовать JpaWalletRepository

2. **REST API**
   - Добавить Spring Boot
   - Создать REST контроллеры

3. **Веб-интерфейс**
   - Frontend на React или Vue.js
   - Графики и диаграммы

4. **Дополнительная аналитика**
   - Прогнозы расходов
   - Рекомендации по бюджету
   - Отчеты за период

5. **Безопасность**
   - JWT токены
   - OAuth2 авторизация
   - Более сильное хэширование (bcrypt)

## Заключение

Архитектура проекта обеспечивает:
- ✅ Чистое разделение ответственности
- ✅ Легкость тестирования
- ✅ Возможность расширения
- ✅ Поддерживаемость кода
- ✅ Следование SOLID принципам

